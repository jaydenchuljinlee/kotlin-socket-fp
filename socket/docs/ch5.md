# 상태 분산(Sharding) 도입 분석 정리

## ✅ 현재 시스템 구조 요약

- WebSocket 기반 채팅 서버
- `roomId`를 기준으로 채팅방 상태(`ChatState`)를 메모리 내 `ChatStateStore`에 저장
- 상태 저장은 단일 노드(Local Memory) 기반
- 클라이언트는 `/topic/chatroom/{roomId}` 경로로 메시지를 송수신
- 메시지는 `ChatCommand → ChatEffect → runEffects` 구조로 처리

---

## 🧨 현재 구조의 한계

| 문제점 | 설명 |
|--------|------|
| ❌ 단일 노드 집중 | 모든 방 상태를 하나의 서버가 관리 → 수평 확장 불가능 |
| ❌ 메모리 병목 | 채팅방 수 증가 시 JVM 메모리 부담 증가 |
| ❌ 상태 공유 불가 | 복수 서버 간 상태 동기화가 되지 않음 |
| ❌ 장애 내성 부족 | 단일 서버 장애 시 전체 채팅 서비스 중단 |
| ❌ 락 경합 | 모든 상태가 하나의 store에 있음 → 동시성 문제 발생 가능 |

---

## ✅ 상태 분산(Sharding) 도입 목적

| 목적 | 기대 효과 |
|------|------------|
| ✅ 수평 확장성 | 채팅방을 여러 노드에 분산 처리 가능 |
| ✅ 메모리 분산 | roomId 단위로 상태를 나누면 메모리 사용 최적화 가능 |
| ✅ 부하 분산 | 특정 방의 트래픽이 많아도 다른 방에는 영향 없음 |
| ✅ 장애 격리 | 하나의 방 상태 장애가 전체에 영향 미치지 않음 |
| ✅ 분산 메시지 처리 | Kafka 등과 연계하여 메시지 라우팅 처리 가능 |

---

## 🧭 도입 방향 예시

### 1. 상태 저장소 분산
- `ChatStateStore`를 분산 가능한 저장소(예: Redis, Hazelcast 등)로 대체
- roomId → 상태 맵핑

### 2. 메시지 라우팅
- Kafka, Redis pub/sub 등으로 메시지를 전파
- `roomId`를 파티셔닝 키로 사용하여 메시지를 특정 shard에 전달

### 3. 서비스 분리
- 방 상태를 처리하는 서비스(Worker)를 여러 인스턴스로 구성
- 각 인스턴스는 특정 `roomId` 범위를 담당 (Consistent Hashing 등)

---

## 🧠 정리: 왜 상태 분산이 필요한가?

현재 구조는 단순하고 로컬 메모리 기반이므로 빠르지만 다음과 같은 한계가 있음:

- 서버 수를 늘릴 수 없음 (수직 확장만 가능)
- 상태가 많아지면 메모리 한계에 도달
- 장애 발생 시 전체 서비스가 영향을 받음

➡️ 이를 해결하기 위해 상태를 분산 처리하고, 메시지를 분산 라우팅할 수 있는 구조로 확장할 필요가 있음

---

## 📌 다음 단계 예고

- [ ] 상태 저장소 Redis 기반 분산 설계
- [ ] Kafka 기반 메시지 파티셔닝 처리
- [ ] roomId → 노드 매핑 로직 설계 (Shard Manager)
